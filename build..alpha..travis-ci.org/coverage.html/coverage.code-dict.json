{"/home/travis/build/npmtest/node-npmtest-minecraft-protocol/test.js":"/* istanbul instrument in package npmtest_minecraft_protocol */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/lib.npmtest_minecraft_protocol.js":"/* istanbul instrument in package npmtest_minecraft_protocol */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_minecraft_protocol = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_minecraft_protocol = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-minecraft-protocol && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_minecraft_protocol */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_minecraft_protocol\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_minecraft_protocol.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_minecraft_protocol.rollup.js'] =\n            local.assetsDict['/assets.npmtest_minecraft_protocol.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_minecraft_protocol.__dirname + '/lib.npmtest_minecraft_protocol.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/index.js":"'use strict';\n\nconst Client = require('./client');\nconst Server = require('./server');\nconst serializer = require(\"./transforms/serializer\");\nconst createClient = require(\"./createClient\");\nconst createServer = require(\"./createServer\");\n\nmodule.exports = {\n  createClient: createClient,\n  createServer: createServer,\n  Client: Client,\n  Server: Server,\n  states: require(\"./states\"),\n  createSerializer:serializer.createSerializer,\n  createDeserializer:serializer.createDeserializer,\n  ping: require('./ping'),\n  supportedVersions:require(\"./version\").supportedVersions\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client.js":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst debug = require('debug')('minecraft-protocol');\nconst compression = require('./transforms/compression');\nconst framing = require('./transforms/framing');\nconst crypto = require('crypto');\nconst states = require(\"./states\");\n\nconst createSerializer=require(\"./transforms/serializer\").createSerializer;\nconst createDeserializer=require(\"./transforms/serializer\").createDeserializer;\n\nclass Client extends EventEmitter\n{\n  constructor(isServer,version,customPackets) {\n    super();\n    this.customPackets=customPackets;\n    this.version=version;\n    this.isServer = !!isServer;\n    this.splitter=framing.createSplitter();\n    this.setSerializer(states.HANDSHAKING);\n    this.packetsToParse={};\n    this.serializer;\n    this.compressor=null;\n    this.framer=framing.createFramer();\n    this.cipher=null;\n    this.decipher=null;\n    this.decompressor=null;\n    this.deserializer;\n    this.isServer;\n    this.protocolState=states.HANDSHAKING;\n    this.ended=true;\n    this.latency=0;\n\n    this.on('newListener', function(event, listener) {\n      const direction = this.isServer ? 'toServer' : 'toClient';\n      if(typeof this.packetsToParse[event] === \"undefined\") this.packetsToParse[event] = 1;\n      else this.packetsToParse[event] += 1;\n    });\n    this.on('removeListener', function(event, listener) {\n      const direction = this.isServer ? 'toServer' : 'toClient';\n      this.packetsToParse[event] -= 1;\n    });\n  }\n\n  get state(){\n    return this.protocolState;\n  }\n\n\n  setSerializer(state) {\n    this.serializer = createSerializer({ isServer:this.isServer, version:this.version, state: state,customPackets:this.customPackets});\n    this.deserializer = createDeserializer({ isServer:this.isServer, version:this.version, state: state, packetsToParse:\n      this.packetsToParse,customPackets:this.customPackets});\n\n    this.splitter.recognizeLegacyPing = state === states.HANDSHAKING;\n\n    this.serializer.on('error', (e) => {\n      let parts;\n      if(e.field) {\n        parts = e.field.split(\".\");\n        parts.shift();\n      }\n      else\n        parts=[];\n      const serializerDirection = !this.isServer ? 'toServer' : 'toClient';\n      e.field = [this.protocolState, serializerDirection].concat(parts).join(\".\");\n      e.message = `Serialization error for ${e.field} : ${e.message}`;\n      if(!this.compressor)\n        this.serializer.pipe(this.framer);\n      else\n        this.serializer.pipe(this.compressor);\n      this.emit('error',e);\n    });\n\n\n    this.deserializer.on('error', (e) => {\n      let parts;\n      if(e.field) {\n        parts = e.field.split(\".\");\n        parts.shift();\n      }\n      else\n        parts=[];\n      const deserializerDirection = this.isServer ? 'toServer' : 'toClient';\n      e.field = [this.protocolState, deserializerDirection].concat(parts).join(\".\");\n      e.message = `Deserialization error for ${e.field} : ${e.message}`;\n      if(!this.compressor)\n        this.splitter.pipe(this.deserializer);\n      else\n        this.decompressor.pipe(this.deserializer);\n      this.emit('error',e);\n    });\n\n    this.deserializer.on('data', (parsed) => {\n      parsed.metadata.name=parsed.data.name;\n      parsed.data=parsed.data.params;\n      parsed.metadata.state=state;\n      debug(\"read packet \" + state + \".\" + parsed.metadata.name);\n      debug(parsed.data);\n      this.emit('packet', parsed.data, parsed.metadata);\n      this.emit(parsed.metadata.name, parsed.data, parsed.metadata);\n      this.emit('raw.' + parsed.metadata.name, parsed.buffer, parsed.metadata);\n      this.emit('raw', parsed.buffer, parsed.metadata);\n    });\n  }\n\n  set state(newProperty) {\n    const oldProperty = this.protocolState;\n    this.protocolState = newProperty;\n\n    if(!this.compressor)\n    {\n      this.serializer.unpipe(this.framer);\n      this.splitter.unpipe(this.deserializer);\n    }\n    else\n    {\n      this.serializer.unpipe(this.compressor);\n      this.decompressor.unpipe(this.deserializer);\n    }\n\n    this.serializer.removeAllListeners();\n    this.deserializer.removeAllListeners();\n    this.setSerializer(this.protocolState);\n\n    if(!this.compressor)\n    {\n      this.serializer.pipe(this.framer);\n      this.splitter.pipe(this.deserializer);\n    }\n    else\n    {\n      this.serializer.pipe(this.compressor);\n      this.decompressor.pipe(this.deserializer);\n    }\n\n    this.emit('state', newProperty, oldProperty);\n  }\n\n  get compressionThreshold() {\n    return this.compressor == null ? -2 : this.compressor.compressionThreshold;\n  }\n\n  set compressionThreshold(threshold) {\n    this.setCompressionThreshold(threshold);\n  }\n\n  setSocket(socket) {\n    this.ended = false;\n\n    // TODO : A lot of other things needs to be done.\n    const endSocket = () => {\n      if(this.ended) return;\n      this.ended = true;\n      this.socket.removeListener('close', endSocket);\n      this.socket.removeListener('end', endSocket);\n      this.socket.removeListener('timeout', endSocket);\n      this.emit('end', this._endReason);\n    };\n\n    const onFatalError = (err) => {\n      this.emit('error', err);\n      endSocket();\n    };\n\n    const onError = (err) => this.emit('error', err);\n\n    this.socket = socket;\n\n    if(this.socket.setNoDelay)\n      this.socket.setNoDelay(true);\n\n    this.socket.on('connect', () => this.emit('connect'));\n\n    this.socket.on('error', onFatalError);\n    this.socket.on('close', endSocket);\n    this.socket.on('end', endSocket);\n    this.socket.on('timeout', endSocket);\n    this.framer.on('error', onError);\n    this.splitter.on('error', onError);\n\n    this.socket.pipe(this.splitter).pipe(this.deserializer);\n    this.serializer.pipe(this.framer).pipe(this.socket);\n  }\n\n  end(reason) {\n    this._endReason = reason;\n    if(this.cipher) this.cipher.unpipe();\n    if(this.framer) this.framer.unpipe();\n    if(this.socket) this.socket.end();\n  }\n\n  setEncryption(sharedSecret) {\n    if (this.cipher != null)\n      throw new Error(\"Set encryption twice !\");\n    this.cipher = crypto.createCipheriv('aes-128-cfb8', sharedSecret, sharedSecret);\n    this.cipher.on('error', (err) => this.emit('error', err));\n    this.framer.unpipe(this.socket);\n    this.framer.pipe(this.cipher).pipe(this.socket);\n    this.decipher = crypto.createDecipheriv('aes-128-cfb8', sharedSecret, sharedSecret);\n    this.decipher.on('error', (err) => this.emit('error', err));\n    this.socket.unpipe(this.splitter);\n    this.socket.pipe(this.decipher).pipe(this.splitter);\n  }\n\n  setCompressionThreshold(threshold) {\n    if (this.compressor == null) {\n      this.compressor = compression.createCompressor(threshold);\n      this.compressor.on('error', (err) => this.emit('error', err));\n      this.serializer.unpipe(this.framer);\n      this.serializer.pipe(this.compressor).pipe(this.framer);\n      this.decompressor = compression.createDecompressor(threshold);\n      this.decompressor.on('error', (err) => this.emit('error', err));\n      this.splitter.unpipe(this.deserializer);\n      this.splitter.pipe(this.decompressor).pipe(this.deserializer);\n    } else {\n      this.decompressor.threshold = threshold;\n      this.compressor.threshold = threshold;\n    }\n  }\n\n  write(name, params) {\n    if(this.ended)\n      return;\n    debug(\"writing packet \" + this.state + \".\" + name);\n    debug(params);\n    this.serializer.write({ name, params });\n  }\n\n  writeRaw(buffer) {\n    if(this.ended)\n      return;\n    if (this.compressor === null)\n      this.framer.write(buffer);\n    else\n      this.compressor.write(buffer);\n  }\n\n  // TCP/IP-specific (not generic Stream) method for backwards-compatibility\n  connect(port, host) {\n    const options = {port, host};\n    if (!this.options) this.options = options;\n    require('./client/tcp_dns')(this, options);\n    options.connect(this);\n  }\n}\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/transforms/compression.js":"'use strict';\n\nconst [readVarInt, writeVarInt, sizeOfVarInt] = require(\"protodef\").types.varint;\nconst zlib = require(\"zlib\");\nconst Transform = require(\"readable-stream\").Transform;\n\nmodule.exports.createCompressor = function(threshold) {\n  return new Compressor(threshold);\n};\n\nmodule.exports.createDecompressor = function(threshold) {\n  return new Decompressor(threshold);\n};\n\nclass Compressor extends Transform {\n  constructor(compressionThreshold = -1) {\n    super();\n    this.compressionThreshold = compressionThreshold;\n  }\n\n  _transform(chunk, enc, cb) {\n    if (chunk.length >= this.compressionThreshold)\n    {\n      zlib.deflate(chunk, (err, newChunk) => {\n        if (err)\n          return cb(err);\n        const buf = new Buffer(sizeOfVarInt(chunk.length) + newChunk.length);\n        const offset = writeVarInt(chunk.length, buf, 0);\n        newChunk.copy(buf, offset);\n        this.push(buf);\n        return cb();\n      });\n    }\n    else\n    {\n      const buf = new Buffer(sizeOfVarInt(0) + chunk.length);\n      const offset = writeVarInt(0, buf, 0);\n      chunk.copy(buf, offset);\n      this.push(buf);\n      return cb();\n    }\n  }\n}\n\nclass Decompressor extends Transform {\n  constructor(compressionThreshold = -1) {\n    super();\n    this.compressionThreshold = compressionThreshold;\n  }\n\n  _transform(chunk, enc, cb) {\n    const { size, value, error } = readVarInt(chunk, 0);\n    if (error)\n      return cb(error);\n    if (value === 0)\n    {\n      this.push(chunk.slice(size));\n      return cb();\n    }\n    else\n    {\n      zlib.inflate(chunk.slice(size), (err, newBuf) => {\n        if (err)\n          return cb(err);\n        this.push(newBuf);\n        return cb();\n      });\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/transforms/framing.js":"'use strict';\n\nconst [readVarInt, writeVarInt, sizeOfVarInt] = require(\"protodef\").types.varint;\nconst Transform = require(\"readable-stream\").Transform;\n\nmodule.exports.createSplitter = function() {\n  return new Splitter();\n};\n\nmodule.exports.createFramer = function() {\n  return new Framer();\n};\n\nclass Framer extends Transform {\n  constructor() {\n    super();\n  }\n\n  _transform(chunk, enc, cb) {\n    const varIntSize=sizeOfVarInt(chunk.length);\n    const buffer = new Buffer(varIntSize + chunk.length);\n    writeVarInt(chunk.length, buffer, 0);\n    chunk.copy(buffer, varIntSize);\n    this.push(buffer);\n    return cb();\n  }\n}\n\nconst LEGACY_PING_PACKET_ID = 0xfe;\n\nclass Splitter extends Transform {\n  constructor() {\n    super();\n    this.buffer = new Buffer(0);\n    this.recognizeLegacyPing = false;\n  }\n  _transform(chunk, enc, cb) {\n    this.buffer = Buffer.concat([this.buffer, chunk]);\n\n    if (this.recognizeLegacyPing && this.buffer[0] === LEGACY_PING_PACKET_ID) {\n      // legacy_server_list_ping packet follows a different protocol format\n      // prefix the encoded varint packet id for the deserializer\n      const header = new Buffer(sizeOfVarInt(LEGACY_PING_PACKET_ID));\n      writeVarInt(LEGACY_PING_PACKET_ID, header, 0);\n      let payload = this.buffer.slice(1); // remove 0xfe packet id\n      if (payload.length === 0) payload = new Buffer('\\0'); // TODO: update minecraft-data to recognize a lone 0xfe, https://github.com/PrismarineJS/minecraft-data/issues/95\n      this.push(Buffer.concat([header, payload]));\n      return cb();\n    }\n\n    let offset = 0;\n    let value, size, error;\n    let stop=false;\n    try {\n      ({ value, size, error } = readVarInt(this.buffer, offset));\n    }\n    catch(e) {\n      if(!(e.partialReadError)) {\n        throw e;\n      }\n      else\n        stop=true;\n    }\n    if(!stop) while (this.buffer.length >= offset + size + value)\n    {\n      try {\n        this.push(this.buffer.slice(offset + size, offset + size + value));\n        offset += size + value;\n        ({value, size, error} = readVarInt(this.buffer, offset));\n      }\n      catch(e) {\n        if(e.partialReadError) {\n          break;\n        }\n        else\n          throw e;\n      }\n    }\n    this.buffer = this.buffer.slice(offset);\n    return cb();\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/states.js":"'use strict';\n\nconst states = {\n  \"HANDSHAKING\": \"handshaking\",\n  \"STATUS\": \"status\",\n  \"LOGIN\": \"login\",\n  \"PLAY\": \"play\"\n};\n\nmodule.exports=states;\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/transforms/serializer.js":"'use strict';\n\nconst ProtoDef = require(\"protodef\").ProtoDef;\nconst Serializer = require(\"protodef\").Serializer;\nconst Parser = require(\"protodef\").Parser;\n\nconst minecraft = require(\"../datatypes/minecraft\");\nconst states = require(\"../states\");\nconst merge=require(\"lodash.merge\");\nconst get=require(\"lodash.get\");\n\nfunction recursiveAddTypes(protocol,protocolData,path)\n{\n  if(protocolData===undefined)\n    return;\n  if(protocolData.types)\n    protocol.addTypes(protocolData.types);\n  recursiveAddTypes(protocol,get(protocolData,path.shift()),path);\n}\n\nconst protocols={};\n\nfunction createProtocol(state,direction,version,customPackets)\n{\n  const key=state+\";\"+direction+\";\"+version;\n  if(protocols[key])\n    return protocols[key];\n  const proto = new ProtoDef();\n  proto.addTypes(minecraft);\n  const mcData=require(\"minecraft-data\")(version);\n  recursiveAddTypes(proto,merge(mcData.protocol,get(customPackets,[mcData.version.majorVersion])),[state,direction]);\n  protocols[key]=proto;\n  return proto;\n}\n\nfunction createSerializer({ state = states.HANDSHAKING, isServer = false , version,customPackets} = {})\n{\n  return new Serializer(createProtocol(state,!isServer ? \"toServer\" : \"toClient\",version,customPackets),\"packet\");\n}\n\nfunction createDeserializer({ state = states.HANDSHAKING, isServer = false,version,customPackets } = {})\n{\n  return new Parser(createProtocol(state,isServer ? \"toServer\" : \"toClient\",version,customPackets),\"packet\");\n}\n\nmodule.exports = {\n  createSerializer:createSerializer,\n  createDeserializer:createDeserializer\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/browser.js":"'use strict';\n\nconst Client = require('./client');\nconst Server = require('./server');\nconst serializer = require(\"./transforms/serializer\");\n\nmodule.exports = {\n  Client: Client,\n  Server: Server,\n  states: require(\"./states\"),\n  createSerializer:serializer.createSerializer,\n  createDeserializer:serializer.createDeserializer,\n  supportedVersions:require(\"./version\").supportedVersions\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/createClient.js":"'use strict';\n\nconst Client = require('./client');\nconst assert = require('assert');\n\nconst encrypt = require('./client/encrypt');\nconst keepalive = require('./client/keepalive');\nconst compress = require('./client/compress');\nconst caseCorrect = require('./client/caseCorrect');\nconst setProtocol = require('./client/setProtocol');\nconst play = require('./client/play');\nconst tcp_dns = require('./client/tcp_dns');\nconst autoVersion = require('./client/autoVersion');\nconst pluginChannels = require('./client/pluginChannels');\n\nmodule.exports=createClient;\n\nfunction createClient(options) {\n  assert.ok(options, \"options is required\");\n  assert.ok(options.username, \"username is required\");\n\n  // TODO: avoid setting default version if autoVersion is enabled\n  const optVersion = options.version || require(\"./version\").defaultVersion;\n  const mcData=require(\"minecraft-data\")(optVersion);\n  if (!mcData) throw new Error(`unsupported protocol version: ${optVersion}`);\n  const version = mcData.version;\n  options.majorVersion = version.majorVersion;\n  options.protocolVersion = version.version;\n\n  const client = new Client(false, version.minecraftVersion,options.customPackets);\n\n  tcp_dns(client, options);\n  caseCorrect(client, options);\n  if (options.version === false) autoVersion(client, options);\n  setProtocol(client, options);\n  keepalive(client, options);\n  encrypt(client, options);\n  play(client, options);\n  compress(client, options);\n  pluginChannels(client, options);\n\n  return client;\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/createServer.js":"'use strict';\n\nconst ursa=require(\"./ursa\");\nconst crypto = require('crypto');\nconst yggserver = require('yggdrasil').server({});\nconst states = require(\"./states\");\nconst bufferEqual = require('buffer-equal');\nconst Server = require('./server');\nconst UUID = require('uuid-1345');\nconst endianToggle = require('endian-toggle');\nconst pluginChannels = require('./client/pluginChannels');\n\nmodule.exports=createServer;\n\nfunction createServer(options) {\n  options = options || {};\n  const port = options.port != null ?\n    options.port :\n    options['server-port'] != null ?\n      options['server-port'] :\n      25565;\n  const host = options.host || '0.0.0.0';\n  const kickTimeout = options.kickTimeout || 30 * 1000;\n  const checkTimeoutInterval = options.checkTimeoutInterval || 4 * 1000;\n  const onlineMode = options['online-mode'] == null ? true : options['online-mode'];\n  // a function receiving the default status object and the client\n  // and returning a modified response object.\n  const beforePing = options.beforePing || null;\n\n  const enableKeepAlive = options.keepAlive == null ? true : options.keepAlive;\n\n  const optVersion = options.version || require(\"./version\").defaultVersion;\n  const mcData=require(\"minecraft-data\")(optVersion);\n  const version = mcData.version;\n\n  const serverKey = ursa.generatePrivateKey(1024);\n\n  const server = new Server(version.minecraftVersion,options.customPackets);\n  server.motd = options.motd || \"A Minecraft server\";\n  server.maxPlayers = options['max-players'] || 20;\n  server.playerCount = 0;\n  server.onlineModeExceptions = {};\n  server.favicon = options.favicon || undefined;\n  \n  server.on(\"connection\", function(client) {\n    client.once('set_protocol', onHandshake);\n    client.once('login_start', onLogin);\n    client.once('ping_start', onPing);\n    client.once('legacy_server_list_ping', onLegacyPing);\n    client.on('end', onEnd);\n\n    let keepAlive = false;\n    let loggedIn = false;\n    let lastKeepAlive = null;\n\n    let keepAliveTimer = null;\n    let loginKickTimer = setTimeout(kickForNotLoggingIn, kickTimeout);\n\n    let serverId;\n\n    let sendKeepAliveTime;\n\n    function kickForNotLoggingIn() {\n      client.end('LoginTimeout');\n    }\n\n    function keepAliveLoop() {\n      if(!keepAlive)\n        return;\n\n      // check if the last keepAlive was too long ago (kickTimeout)\n      const elapsed = new Date() - lastKeepAlive;\n      if(elapsed > kickTimeout) {\n        client.end('KeepAliveTimeout');\n        return;\n      }\n      sendKeepAliveTime = new Date();\n      client.write('keep_alive', {\n        keepAliveId: Math.floor(Math.random() * 2147483648)\n      });\n    }\n\n    function onKeepAlive() {\n      if(sendKeepAliveTime) client.latency = (new Date()) - sendKeepAliveTime;\n      lastKeepAlive = new Date();\n    }\n\n    function startKeepAlive() {\n      keepAlive = true;\n      lastKeepAlive = new Date();\n      keepAliveTimer = setInterval(keepAliveLoop, checkTimeoutInterval);\n      client.on('keep_alive', onKeepAlive);\n    }\n\n    function onEnd() {\n      clearInterval(keepAliveTimer);\n      clearTimeout(loginKickTimer);\n    }\n\n    function onPing() {\n      const response = {\n        \"version\": {\n          \"name\": version.minecraftVersion,\n          \"protocol\": version.version\n        },\n        \"players\": {\n          \"max\": server.maxPlayers,\n          \"online\": server.playerCount,\n          \"sample\": []\n        },\n        \"description\": {\"text\": server.motd},\n        \"favicon\": server.favicon\n      };\n\n      function answerToPing(err, response) {\n        if ( err ) return;\n        client.write('server_info', {response: JSON.stringify(response)});\n      }\n\n      if(beforePing) {\n        if ( beforePing.length > 2 ) {\n          beforePing(response, client, answerToPing);\n        } else {\n          answerToPing(null, beforePing(response, client) || response);\n        }\n      } else {\n        answerToPing(null, response);\n      }\n\n      client.once('ping', function(packet) {\n        client.write('ping', {time: packet.time});\n        client.end();\n      });\n    }\n\n    function onLegacyPing(packet) {\n      if (packet.payload === 1) {\n        const pingVersion = 1;\n        sendPingResponse('\\xa7' + [pingVersion, version.version, version.minecraftVersion,\n            server.motd, server.playerCount.toString(), server.maxPlayers.toString()].join('\\0'));\n      } else {\n        // ping type 0\n        sendPingResponse([server.motd, server.playerCount.toString(), server.maxPlayers.toString()].join('\\xa7'));\n      }\n\n      function sendPingResponse(responseString) {\n        function utf16be(s) {\n          return endianToggle(new Buffer(s, 'utf16le'), 16);\n        }\n\n        const responseBuffer = utf16be(responseString);\n\n        const length = responseString.length; // UCS2 characters, not bytes\n        const lengthBuffer = new Buffer(2);\n        lengthBuffer.writeUInt16BE(length);\n\n        const raw = Buffer.concat([new Buffer('ff', 'hex'), lengthBuffer, responseBuffer]);\n\n        //client.writeRaw(raw); // not raw enough, it includes length\n        client.socket.write(raw);\n      }\n\n    }\n\n    function onLogin(packet) {\n      client.username = packet.username;\n      const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];\n      const needToVerify = (onlineMode && !isException) || (!onlineMode && isException);\n      if(needToVerify) {\n        serverId = crypto.randomBytes(4).toString('hex');\n        client.verifyToken = crypto.randomBytes(4);\n        const publicKeyStrArr = serverKey.toPublicPem(\"utf8\").split(\"\\n\");\n        let publicKeyStr = \"\";\n        for(let i = 1; i < publicKeyStrArr.length - 2; i++) {\n          publicKeyStr += publicKeyStrArr[i]\n        }\n        client.publicKey = new Buffer(publicKeyStr, 'base64');\n        client.once('encryption_begin', onEncryptionKeyResponse);\n        client.write('encryption_begin', {\n          serverId: serverId,\n          publicKey: client.publicKey,\n          verifyToken: client.verifyToken\n        });\n      } else {\n        loginClient();\n      }\n    }\n\n    function onHandshake(packet) {\n      client.serverHost = packet.serverHost;\n      client.serverPort = packet.serverPort;\n      client.protocolVersion = packet.protocolVersion;\n      if(packet.nextState == 1) {\n        client.state = states.STATUS;\n      } else if(packet.nextState == 2) {\n        client.state = states.LOGIN;\n      }\n      if(client.protocolVersion!=version.version)\n      {\n        client.end(\"Wrong protocol version, expected: \"+version.version+\" and you are using: \"+client.protocolVersion);\n      }\n    }\n\n    function onEncryptionKeyResponse(packet) {\n      let sharedSecret;\n      try {\n        const verifyToken = serverKey.decrypt(packet.verifyToken, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n        if(!bufferEqual(client.verifyToken, verifyToken)) {\n          client.end('DidNotEncryptVerifyTokenProperly');\n          return;\n        }\n        sharedSecret = serverKey.decrypt(packet.sharedSecret, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n      } catch(e) {\n        client.end('DidNotEncryptVerifyTokenProperly');\n        return;\n      }\n      client.setEncryption(sharedSecret);\n\n      const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];\n      const needToVerify = (onlineMode && !isException) || (!onlineMode && isException);\n      const nextStep = needToVerify ? verifyUsername : loginClient;\n      nextStep();\n\n      function verifyUsername() {\n        yggserver.hasJoined(client.username, serverId, sharedSecret, client.publicKey, function(err, profile) {\n          if(err) {\n            client.end(\"Failed to verify username!\");\n            return;\n          }\n          // Convert to a valid UUID until the session server updates and does\n          // it automatically\n          client.uuid = profile.id.replace(/(\\w{8})(\\w{4})(\\w{4})(\\w{4})(\\w{12})/, \"$1-$2-$3-$4-$5\");\n          client.profile = profile;\n          loginClient();\n        });\n      }\n    }\n\n\n    // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/UUID.java#L163\n    function javaUUID(s)\n    {\n      const hash = crypto.createHash(\"md5\");\n      hash.update(s, 'utf8');\n      const buffer = hash.digest();\n      buffer[6] = (buffer[6] & 0x0f) | 0x30;\n      buffer[8] = (buffer[8] & 0x3f) | 0x80;\n      return buffer;\n    }\n\n    function nameToMcOfflineUUID(name)\n    {\n      return (new UUID(javaUUID(\"OfflinePlayer:\"+name))).toString();\n    }\n\n    function loginClient() {\n      const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];\n      if(onlineMode == false || isException) {\n        client.uuid = nameToMcOfflineUUID(client.username);\n      }\n      if (version.version >= 27) { // 14w28a (27) added whole-protocol compression (http://wiki.vg/Protocol_History#14w28a), earlier versions per-packet compressed TODO: refactor into minecraft-data\n        client.write('compress', { threshold: 256 }); // Default threshold is 256\n        client.compressionThreshold = 256;\n      }\n      client.write('success', {uuid: client.uuid, username: client.username});\n      client.state = states.PLAY;\n      loggedIn = true;\n      if(enableKeepAlive) startKeepAlive();\n\n      clearTimeout(loginKickTimer);\n      loginKickTimer = null;\n\n      server.playerCount += 1;\n      client.once('end', function() {\n        server.playerCount -= 1;\n      });\n      pluginChannels(client, options);\n      server.emit('login', client);\n    }\n  });\n  server.listen(port, host);\n  return server;\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/ursa.js":"'use strict';\n\nlet ursa;\ntry {\n  ursa = require(\"ursa\");\n} catch(e) {\n  console.log(\"You are using a pure-javascript implementation of RSA.\");\n  console.log(\"Your performance might be subpar. Please consider installing URSA\");\n  ursa = require(\"ursa-purejs\");\n}\nmodule.exports=ursa;\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/server.js":"'use strict';\n\nconst net = require('net');\nconst EventEmitter = require('events').EventEmitter;\nconst Client = require('./client');\nconst states = require(\"./states\");\n\nclass Server extends EventEmitter\n{\n  constructor(version,customPackets) {\n    super();\n    this.version=version;\n    this.socketServer=null;\n    this.cipher=null;\n    this.decipher=null;\n    this.clients={};\n    this.customPackets=customPackets;\n  }\n\n  listen(port, host) {\n    const self = this;\n    let nextId = 0;\n    self.socketServer = net.createServer();\n    self.socketServer.on('connection', socket => {\n      const client = new Client(true,this.version,this.customPackets);\n      client._end = client.end;\n      client.end = function end(endReason) {\n        endReason='{\"text\":\"'+endReason+'\"}';\n        if(client.state === states.PLAY) {\n          client.write('kick_disconnect', {reason: endReason});\n        } else if(client.state === states.LOGIN) {\n          client.write('disconnect', {reason: endReason});\n        }\n        client._end(endReason);\n      };\n      client.id = nextId++;\n      self.clients[client.id] = client;\n      client.on('end', function() {\n        delete self.clients[client.id];\n      });\n      client.setSocket(socket);\n      self.emit('connection', client);\n    });\n    self.socketServer.on('error', function(err) {\n      self.emit('error', err);\n    });\n    self.socketServer.on('close', function() {\n      self.emit('close');\n    });\n    self.socketServer.on('listening', function() {\n      self.emit('listening');\n    });\n    self.socketServer.listen(port, host);\n  }\n\n  close() {\n    Object.keys(this.clients).forEach(clientId => {\n      const client = this.clients[clientId];\n      client.end('ServerShutdown');\n    });\n    this.socketServer.close();\n  }\n}\n\nmodule.exports = Server;\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/ping.js":"'use strict';\n\nconst net = require('net');\nconst Client = require('./client');\nconst states = require(\"./states\");\nconst tcp_dns = require('./client/tcp_dns');\n\nmodule.exports = ping;\n\nfunction ping(options, cb) {\n  options.host = options.host || 'localhost';\n  options.port = options.port || 25565;\n  const optVersion = options.version || require(\"./version\").defaultVersion;\n  const mcData=require(\"minecraft-data\")(optVersion);\n  const version = mcData.version;\n  options.majorVersion = version.majorVersion;\n  options.protocolVersion = version.version;\n\n  const client = new Client(false,options.majorVersion);\n  client.on('error', function(err) {\n    cb(err);\n  });\n\n  client.once('server_info', function(packet) {\n    const data = JSON.parse(packet.response);\n    const start = Date.now();\n    client.once('ping', function(packet) {\n      data.latency = Date.now() - start;\n      cb(null, data);\n      client.end();\n    });\n    client.write('ping', {time: [0, 0]});\n  });\n\n  client.on('state', function(newState) {\n    if(newState === states.STATUS)\n      client.write('ping_start', {});\n  });\n\n  // TODO: refactor with src/client/setProtocol.js\n  client.on('connect', function() {\n    client.write('set_protocol', {\n      protocolVersion: options.protocolVersion,\n      serverHost: options.host,\n      serverPort: options.port,\n      nextState: 1\n    });\n    client.state = states.STATUS;\n  });\n\n  tcp_dns(client, options);\n  options.connect(client);\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/version.js":"'use strict';\n\nmodule.exports={\n  defaultVersion:'1.8',\n  supportedVersions:['1.7','1.8','1.9','1.10','1.11.2']\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/autoVersion.js":"'use strict';\n\nconst ping = require('../ping');\nconst debug = require('debug')('minecraft-protocol');\nconst states = require('../states');\nconst assert = require('assert');\nconst minecraft_data = require('minecraft-data');\n\nmodule.exports = function(client, options) {\n  client.wait_connect = true; // don't let src/client/setProtocol proceed on socket 'connect' until 'connect_allowed'\n  debug('pinging',options.host);\n  const pingOptions = {host: options.host, port: options.port};\n  // TODO: use 0xfe ping instead for better compatibility/performance? https://github.com/deathcap/node-minecraft-ping\n  ping(pingOptions, function(err, response) {\n    if (err) throw err; // hmm\n    debug('ping response',response);\n    // TODO: could also use ping pre-connect to save description, type, max players, etc.\n    const motd = response.description;\n    debug('Server description:',motd); // TODO: save\n\n    // Pass server-reported version to protocol handler\n    // The version string is interpreted by https://github.com/PrismarineJS/node-minecraft-data\n    const brandedMinecraftVersion = response.version.name;        // 1.8.9, 1.7.10\n    const protocolVersion = response.version.protocol;//    47,      5\n\n    debug(`Server version: ${brandedMinecraftVersion}, protocol: ${protocolVersion}`);\n\n    let minecraftVersion;\n    if (brandedMinecraftVersion.indexOf(' ') !== -1) {\n      // Spigot and Glowstone++ prepend their name; strip it off\n      minecraftVersion = brandedMinecraftVersion.split(' ')[1];\n    } else {\n      minecraftVersion = brandedMinecraftVersion;\n    }\n\n    const versionInfo = minecraft_data.versionsByMinecraftVersion[\"pc\"][minecraftVersion];\n    if (!versionInfo) throw new Error(`unsupported/unknown protocol version: ${protocolVersion}, update minecraft-data`);\n\n    options.version = minecraftVersion;\n    options.protocolVersion = protocolVersion;\n\n    // Reinitialize client object with new version TODO: move out of its constructor?\n    client.version = minecraftVersion;\n    client.state = states.HANDSHAKING;\n\n    // Let other plugins such as Forge/FML (modinfo) respond to the ping response\n    if (client.autoVersionHooks) {\n      client.autoVersionHooks.forEach((hook) => {\n        hook(response, client, options);\n      });\n    }\n\n    // Finished configuring client object, let connection proceed\n    client.emit('connect_allowed');\n  });\n  return client;\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/caseCorrect.js":"const yggdrasil = require('yggdrasil')({});\nconst UUID = require('uuid-1345');\n\nmodule.exports = function(client, options) {\n  const clientToken = options.clientToken || UUID.v4().toString();\n  options.accessToken = null;\n  options.haveCredentials = options.password != null || (clientToken != null && options.session != null);\n\n  if(options.haveCredentials) {\n    // make a request to get the case-correct username before connecting.\n    const cb = function(err, session) {\n      if(err) {\n        client.emit('error', err);\n      } else {\n        client.session = session;\n        client.username = session.selectedProfile.name;\n        options.accessToken = session.accessToken;\n        client.emit('session');\n        options.connect(client);\n      }\n    };\n\n    if (options.session) {\n      yggdrasil.validate(options.session.accessToken, function(err) {\n        if (!err)\n          cb(null, options.session);\n        else\n          yggdrasil.refresh(options.session.accessToken, options.session.clientToken, function(err, data) {\n            cb(err, data);\n          });\n      });\n    }\n    else yggdrasil.auth({\n      user: options.username,\n      pass: options.password,\n      token: clientToken\n    }, cb);\n  } else {\n    // assume the server is in offline mode and just go for it.\n    client.username = options.username;\n    options.connect(client);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/compress.js":"module.exports = function(client, options) {\n  client.once(\"compress\", onCompressionRequest);\n  client.on(\"set_compression\", onCompressionRequest);\n\n  function onCompressionRequest(packet) {\n    client.compressionThreshold = packet.threshold;\n  }\n  // TODO: refactor with transforms/compression.js -- enable it here\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/encrypt.js":"'use strict';\n\nconst crypto = require('crypto');\nconst yggserver = require('yggdrasil').server({});\nconst ursa=require(\"../ursa\");\nconst debug = require('debug')('minecraft-protocol');\n\nmodule.exports = function(client, options) {\n  client.once('encryption_begin', onEncryptionKeyRequest);\n\n  function onEncryptionKeyRequest(packet) {\n    crypto.randomBytes(16, gotSharedSecret);\n\n    function gotSharedSecret(err, sharedSecret) {\n      if(err) {\n        debug(err);\n        client.emit('error', err);\n        client.end();\n        return;\n      }\n      if(options.haveCredentials) {\n        joinServerRequest(onJoinServerResponse);\n      } else {\n        if(packet.serverId != '-') {\n          debug('This server appears to be an online server and you are providing no password, the authentication will probably fail');\n        }\n        sendEncryptionKeyResponse();\n      }\n\n      function onJoinServerResponse(err) {\n        if(err) {\n          client.emit('error', err);\n          client.end();\n        } else {\n          sendEncryptionKeyResponse();\n        }\n      }\n\n      function joinServerRequest(cb) {\n        yggserver.join(options.accessToken, client.session.selectedProfile.id,\n            packet.serverId, sharedSecret, packet.publicKey, cb);\n      }\n\n      function sendEncryptionKeyResponse() {\n        const pubKey = mcPubKeyToURsa(packet.publicKey);\n        const encryptedSharedSecretBuffer = pubKey.encrypt(sharedSecret, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n        const encryptedVerifyTokenBuffer = pubKey.encrypt(packet.verifyToken, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n        client.write('encryption_begin', {\n          sharedSecret: encryptedSharedSecretBuffer,\n          verifyToken: encryptedVerifyTokenBuffer\n        });\n        client.setEncryption(sharedSecret);\n      }\n    }\n  }\n};\n\nfunction mcPubKeyToURsa(mcPubKeyBuffer) {\n  let pem = \"-----BEGIN PUBLIC KEY-----\\n\";\n  let base64PubKey = mcPubKeyBuffer.toString('base64');\n  const maxLineLength = 65;\n  while(base64PubKey.length > 0) {\n    pem += base64PubKey.substring(0, maxLineLength) + \"\\n\";\n    base64PubKey = base64PubKey.substring(maxLineLength);\n  }\n  pem += \"-----END PUBLIC KEY-----\\n\";\n  return ursa.createPublicKey(pem, 'utf8');\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/keepalive.js":"'use strict';\n\nmodule.exports = function(client, options) {\n  const keepAlive = options.keepAlive == null ? true : options.keepAlive;\n  if (!keepAlive) return;\n\n  const checkTimeoutInterval = options.checkTimeoutInterval || 20 * 1000;\n\n  client.on('keep_alive', onKeepAlive);\n\n  let timeout = null;\n\n  function onKeepAlive(packet) {\n    if (timeout)\n      clearTimeout(timeout);\n    timeout = setTimeout(() => client.end(), checkTimeoutInterval);\n    client.write('keep_alive', {\n      keepAliveId: packet.keepAliveId\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/play.js":"const states = require(\"../states\");\n\nmodule.exports = function(client, options) {\n  client.once('success', onLogin);\n\n  function onLogin(packet) {\n    client.state = states.PLAY;\n    client.uuid = packet.uuid;\n    client.username = packet.username;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/pluginChannels.js":"var ProtoDef = require('protodef').ProtoDef;\nvar minecraft = require('../datatypes/minecraft');\n\nmodule.exports = function(client, options) {\n  var mcdata = require('minecraft-data')(options.version || require(\"../version\").defaultVersion);\n  var channels = [];\n  var proto = new ProtoDef();\n  proto.addTypes(mcdata.protocol.types);\n  proto.addTypes(minecraft);\n  proto.addType('registerarr',[readDumbArr, writeDumbArr, sizeOfDumbArr]);\n\n  client.registerChannel = registerChannel;\n  client.unregisterChannel = unregisterChannel;\n  client.writeChannel = writeChannel;\n\n  client.registerChannel(\"REGISTER\",[\"registerarr\",[]]);\n  client.registerChannel(\"UNREGISTER\",[\"registerarr\",[]]);\n\n\n  function registerChannel(name, parser, custom) {\n    if(custom) {\n      client.writeChannel(\"REGISTER\",name);\n    }\n    if (parser) proto.addType(name, parser);\n    channels.push(name);\n    if (channels.length === 1)\n      client.on('custom_payload', onCustomPayload);\n  }\n\n  function unregisterChannel(channel, custom) {\n    if(custom) {\n      client.writeChannel(\"UNREGISTER\",channel);\n    }\n    var index = channels.find(function(name) {\n      return channel === name;\n    });\n    if (index) {\n      proto.types[channel] = undefined;\n      channels.splice(index, 1);\n      if (channels.length === 0)\n        client.removeListener('custom_payload', onCustomPayload);\n    }\n  }\n\n  function onCustomPayload(packet) {\n    var channel = channels.find(function(channel) {\n      return channel === packet.channel;\n    });\n    if (channel) {\n      if (proto.types[channel])\n        packet.data = proto.parsePacketBuffer(channel, packet.data).data;\n      client.emit(channel, packet.data);\n    }\n  }\n\n  function writeChannel(channel,params) {\n    client.write(\"custom_payload\",{\n        channel:channel,\n        data:proto.createPacketBuffer(channel,params)\n      });\n  }\n\n  function readDumbArr(buf, offset) {\n    var ret = {\n      value: [],\n      size: 0\n    };\n    let results;\n    while (offset < buf.length) {\n      if (buf.indexOf(0x0, offset) == -1)\n        results = this.read(buf, offset, \"restBuffer\", {});\n      else\n        results = this.read(buf, offset, \"cstring\", {});\n      ret.size += results.size;\n      ret.value.push(results.value.toString());\n      offset += results.size;\n    }\n    return ret;\n  }\n\n  function writeDumbArr(value, buf, offset) {\n    // TODO: Remove trailing \\0\n    value.forEach(function(v) {\n      offset += this.write(v, buf, offset, \"cstring\", {});\n    });\n    return offset;\n  }\n\n  function sizeOfDumbArr(value) {\n    return value.reduce((acc, v) => acc + this.sizeOf(v, \"cstring\", {}), 0);\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/datatypes/minecraft.js":"'use strict';\n\nconst nbt = require('prismarine-nbt');\nconst UUID = require('uuid-1345');\nconst zlib = require('zlib');\n\nmodule.exports = {\n  'UUID': [readUUID, writeUUID, 16],\n  'nbt': [readNbt, writeNbt, sizeOfNbt],\n  'optionalNbt':[readOptionalNbt,writeOptionalNbt,sizeOfOptionalNbt],\n  'compressedNbt':[readCompressedNbt,writeCompressedNbt,sizeOfCompressedNbt],\n  'restBuffer': [readRestBuffer, writeRestBuffer, sizeOfRestBuffer],\n  'entityMetadataLoop': [readEntityMetadata, writeEntityMetadata, sizeOfEntityMetadata]\n};\nvar PartialReadError=require('protodef').utils.PartialReadError;\n\nfunction readUUID(buffer, offset) {\n  if(offset+16>buffer.length)\n    throw new PartialReadError();\n  return {\n    value: UUID.stringify(buffer.slice(offset,16+offset)),\n    size: 16\n  };\n}\n\nfunction writeUUID(value, buffer, offset) {\n  const buf=UUID.parse(value);\n  buf.copy(buffer,offset);\n  return offset + 16;\n}\n\nfunction readNbt(buffer, offset) {\n  return nbt.proto.read(buffer,offset,\"nbt\");\n}\n\nfunction writeNbt(value, buffer, offset) {\n  return nbt.proto.write(value,buffer,offset,\"nbt\");\n}\n\nfunction sizeOfNbt(value) {\n  return nbt.proto.sizeOf(value,\"nbt\");\n}\n\n\nfunction readOptionalNbt(buffer, offset) {\n  if(offset+1>buffer.length)\n    throw new PartialReadError();\n  if(buffer.readInt8(offset) == 0) return {size:1};\n  return nbt.proto.read(buffer,offset,\"nbt\");\n}\n\nfunction writeOptionalNbt(value, buffer, offset) {\n  if(value==undefined) {\n    buffer.writeInt8(0,offset);\n    return offset+1;\n  }\n  return nbt.proto.write(value,buffer,offset,\"nbt\");\n}\n\nfunction sizeOfOptionalNbt(value) {\n  if(value==undefined)\n    return 1;\n  return nbt.proto.sizeOf(value,\"nbt\");\n}\n\n// Length-prefixed compressed NBT, see differences: http://wiki.vg/index.php?title=Slot_Data&diff=6056&oldid=4753\nfunction readCompressedNbt(buffer, offset) {\n  if(offset+2>buffer.length)\n    throw new PartialReadError();\n  const length = buffer.readInt16BE(offset);\n  if(length == -1) return {size:2};\n  if(offset+2+length>buffer.length)\n    throw new PartialReadError();\n\n  const compressedNbt = buffer.slice(offset+2, offset+2+length);\n\n  const nbtBuffer = zlib.gunzipSync(compressedNbt); // TODO: async\n\n  const results=nbt.proto.read(nbtBuffer,0,\"nbt\");\n  return {\n    size:length+2,\n    value:results.value\n  }\n}\n\nfunction writeCompressedNbt(value, buffer, offset) {\n  if(value==undefined) {\n    buffer.writeInt16BE(-1,offset);\n    return offset+2;\n  }\n  const nbtBuffer = new Buffer(sizeOfNbt(value));\n  nbt.proto.write(value,nbtBuffer,0,\"nbt\");\n\n  const compressedNbt = zlib.gzipSync(nbtBuffer); // TODO: async\n  compressedNbt.writeUInt8(0, 9); // clear the OS field to match MC\n\n  buffer.writeInt16BE(compressedNbt.length,offset);\n  compressedNbt.copy(buffer,offset+2);\n  return offset+2+compressedNbt.length;\n}\n\nfunction sizeOfCompressedNbt(value) {\n  if(value==undefined)\n    return 2;\n\n  const nbtBuffer = new Buffer(sizeOfNbt(value,\"nbt\"));\n  nbt.proto.write(value,nbtBuffer,0,\"nbt\");\n\n  const compressedNbt = zlib.gzipSync(nbtBuffer); // TODO: async\n\n  return 2+compressedNbt.length;\n}\n\n\n\nfunction readRestBuffer(buffer, offset) {\n  return {\n    value: buffer.slice(offset),\n    size: buffer.length - offset\n  };\n}\n\nfunction writeRestBuffer(value, buffer, offset) {\n  value.copy(buffer, offset);\n  return offset + value.length;\n}\n\nfunction sizeOfRestBuffer(value) {\n  return value.length;\n}\n\nfunction readEntityMetadata(buffer, offset, {type,endVal}) {\n  let cursor = offset;\n  const metadata = [];\n  let item;\n  while(true) {\n    if(offset+1>buffer.length)\n      throw new PartialReadError();\n    item = buffer.readUInt8(cursor);\n    if(item === endVal) {\n      return {\n        value: metadata,\n        size: cursor + 1 - offset\n      };\n    }\n    const results = this.read(buffer, cursor, type, {});\n    metadata.push(results.value);\n    cursor += results.size;\n  }\n}\n\nfunction writeEntityMetadata(value, buffer, offset, {type,endVal}) {\n  const self = this;\n  value.forEach(function(item) {\n    offset = self.write(item, buffer, offset, type, {});\n  });\n  buffer.writeUInt8(endVal, offset);\n  return offset + 1;\n}\n\nfunction sizeOfEntityMetadata(value, {type}) {\n  let size = 1;\n  for(let i = 0; i < value.length; ++i) {\n    size += this.sizeOf(value[i], type, {});\n  }\n  return size;\n}\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/setProtocol.js":"'use strict';\n\nconst states = require(\"../states\");\n\nmodule.exports = function(client, options) {\n  client.on('connect', onConnect);\n\n  function onConnect() {\n    if (client.wait_connect) {\n      client.on('connect_allowed', next);\n    } else {\n      next();\n    }\n\n    function next() {\n      let taggedHost = options.host;\n      if (client.tagHost) taggedHost += client.tagHost;\n\n      client.write('set_protocol', {\n        protocolVersion: options.protocolVersion,\n        serverHost: taggedHost,\n        serverPort: options.port,\n        nextState: 2\n      });\n      client.state = states.LOGIN;\n      client.write('login_start', {\n        username: client.username\n      });\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-minecraft-protocol/node_modules/minecraft-protocol/src/client/tcp_dns.js":"const net = require('net');\nconst dns = require('dns');\n\nmodule.exports = function(client, options) {\n  options.port = options.port || 25565;\n  options.host = options.host || 'localhost';\n\n  options.connect = (client) => {\n    if (options.stream) {\n      client.setSocket(options.stream);\n    } else if (options.port == 25565 && net.isIP(options.host) === 0) {\n      dns.resolveSrv(\"_minecraft._tcp.\" + options.host, function(err, addresses) {\n        if(addresses && addresses.length > 0) {\n          client.setSocket(net.connect(addresses[0].port, addresses[0].name));\n        } else {\n          client.setSocket(net.connect(options.port, options.host));\n        }\n      });\n    } else {\n      client.setSocket(net.connect(options.port, options.host));\n    }\n  };\n};\n"}